# Plan-document models
#topic
#concept
**Related:**
-  

---

![[Agile]]

## Waterfall Software Dev Lifecycle
Complete each stage before the next, going back is a huge deal and is avoided
Because catching mistakes earlier is better 
Plan and document approach is not very well suited for today if you get paid for the service and not how long it takes

Phases: 
1. Requirements analysis and specification  
2. Architectural design  
3. Implementation and Integration  
4. Verification  
5. Operation and Maintenance

Complete one phase at a time, usually takes between 6-18 months

However, users don't usually know what they want, which led to the spiral model

## Spiral model
BDUF + prototypes, develop requirements across iterations 
Finish one section at a time but repeatedly go through them in prototypes 

Phases:
1. Determine objectives and constraints of this iteration  
2. Evaluate alternatives and identify and resolve risks  
3. Develop and verify the prototype for this iteration  
4. Plan the next iteration

6-24 months long, iterations involve customer before product is completed

## Rational Unified Process (RUP)
Latest representation of Plan-and-Document lifecycles 

1. Inception: makes the business case for the software and scopes the project to set the  schedule and budget, which is used to judge progress and justify expenditures, and  initial assessment of risks to schedule and budget.  
2. Elaboration: works with stakeholders to identify use cases, designs a software architecture, sets the development plan, and builds an initial prototype.  
3. Construction: codes and tests the product, resulting in the first external release.  
4. Transition: moves the product from development to production in the real environment,  including customer acceptance testing and user training.


- The phases are dynamic and you could revisit one several times or repeatedly iterate over them like in spiral
- Also use prototyping
- Tied more closely to business objectives 

Engineering disciplines: 
1. Business Modeling  
2. Requirements  
3. Analysis and Design  
4. Implementation  
5. Test  
6. Deployment